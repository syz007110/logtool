<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>单场手术可视化（表格风格时间轴）</title>

  <!-- ECharts CDN -->
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>

  <style>
    :root{
      --bg:#f6f8fb;
      --card:#ffffff;
      --muted:#6b7280;
      --accent:#183047;
    }
    body{
      margin:0;
      font-family: "Helvetica Neue", Arial, "PingFang SC", "Microsoft Yahei", sans-serif;
      background:var(--bg);
      color:#111827;
    }
    .container{
      max-width:1200px;
      margin:18px auto;
      padding:18px;
    }
    .toolbar{
      display:flex;
      gap:12px;
      align-items:center;
      margin-bottom:12px;
    }
    .select, .btn{
      background:var(--card);
      border-radius:8px;
      padding:8px 12px;
      box-shadow:0 1px 2px rgba(0,0,0,0.04);
      border:1px solid rgba(0,0,0,0.04);
    }
    .select select{ border:0; font-size:14px; background:transparent; outline:none;}
    .btn { cursor:pointer; color: white; background: #0b5cff; border: none; }
    .card{
      background:var(--card);
      border-radius:12px;
      padding:14px;
      box-shadow:0 6px 18px rgba(15,23,42,0.06);
      margin-bottom:14px;
    }
    .timeline-wrap{ height:360px; }
    .charts-row{ display:flex; gap:12px; margin-top:12px; }
    .chart-sm{ flex:1; height:220px; background:var(--card); border-radius:12px; padding:8px; box-shadow:0 4px 10px rgba(15,23,42,0.03); }
    .bottom-table{ margin-top:12px; background:var(--card); border-radius:12px; padding:8px; }
    table{ width:100%; border-collapse:collapse; font-size:13px; color:#111827;}
    thead tr{ background:#f3f6fb; }
    th, td{ padding:8px 10px; border-bottom:1px solid #f1f5f9; text-align:left; }
    .badge{ display:inline-block; padding:4px 8px; border-radius:12px; font-size:12px; color:#fff; }
    .badge.handled{ background:#22c55e; }
    .badge.unhandled{ background:#f97316; }
    .tooltip-custom{
      background:#fff; padding:8px; border-radius:6px; box-shadow: 0 6px 18px rgba(0,0,0,0.12);
      font-size:13px;
    }
    /* small responsive */
    @media (max-width:900px){
      .container{ padding:8px; }
      .timeline-wrap{ height:300px; }
      .chart-sm{ height:180px; }
    }
    /* table row selected */
    tr.row-selected{ background: #EEF8FF; }
  </style>
</head>
<body>
  <div class="container">
    <div class="toolbar">
      <div class="select card">
        <select id="surgerySelect">
          <option value="s1">4358-08-202508241233（远程）</option>
          <option value="s2">4358-08-202509120900（本地）</option>
        </select>
      </div>
      <div class="btn" id="exportBtn">导出手术数据</div>
      <div style="margin-left:auto;color:var(--muted)">手术可视化 - 单场预览</div>
    </div>

    <!-- 时间轴区域 -->
    <div class="card">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
        <div style="font-weight:600">手术情况</div>
        <div style="font-size:13px; color:var(--muted)">时间轴以小时为分割，点击区块或标记查看详情</div>
      </div>
      <div id="timeline" class="timeline-wrap"></div>
    </div>

    <!-- 下方折线图 -->
    <div class="charts-row">
      <div id="stateChart" class="chart-sm card"></div>
      <div id="networkChart" class="chart-sm card"></div>
    </div>

    <!-- 报警表格 -->
    <div class="bottom-table card">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <div style="font-weight:600">安全报警记录</div>
        <div style="font-size:13px;color:var(--muted)">Total 46 items</div>
      </div>
      <div style="overflow:auto; max-height:240px;">
        <table id="alarmTable">
          <thead>
            <tr>
              <th>时间</th><th>故障码</th><th>报警信息</th><th>处理状态</th>
            </tr>
          </thead>
          <tbody id="alarmTbody">
            <!-- rows programmatically generated -->
          </tbody>
        </table>
      </div>
    </div>
  </div>

<script>
/*******************************
 * 示例数据（可替换为后端返回的 surgeries.structured_data）
 *******************************/
const surgeryStart = new Date('2025-09-12T12:00:00').getTime();
const surgeryEnd   = new Date('2025-09-12T23:30:00').getTime();

// 工具臂使用区块： [armIndex, startMs, endMs, label, udi, type]
const usageBlocks = [
  [3, new Date('2025-09-12T12:12:00').getTime(), new Date('2025-09-12T14:50:00').getTime(), 'IN 8033-2503036', 'IN8033-2503036', 'camera'],
  [2, new Date('2025-09-12T15:10:00').getTime(), new Date('2025-09-12T19:00:00').getTime(), 'IN 8033-2503036', 'IN8033-2503036', 'scalpel'],
  [2, new Date('2025-09-12T20:05:00').getTime(), new Date('2025-09-12T21:50:00').getTime(), 'IN 8033-2503036', 'IN8033-2503036', 'scalpel'],
  [1, new Date('2025-09-12T14:30:00').getTime(), new Date('2025-09-12T14:50:00').getTime(), 'IN-2411067', 'IN8035-2411067', 'forceps'],
  [0, new Date('2025-09-12T16:00:00').getTime(), new Date('2025-09-12T18:30:00').getTime(), 'IN 8033-2503036', 'IN8033-2503036', 'stapler'],
  [3, new Date('2025-09-12T18:00:00').getTime(), new Date('2025-09-12T19:05:00').getTime(), 'IN 8033-2503036', 'IN8033-2503036', 'camera'],
];

// 故障事件： [timeMs, armIndex (for display), code, level]
const faults = [
  [new Date('2025-09-12T12:10:00').getTime(), 0, '2819211e', 'A'],
  [new Date('2025-09-12T19:42:00').getTime(), 2, '416d', 'A'],
  [new Date('2025-09-12T21:18:00').getTime(), 3, '2819211e', 'B']
];

// 状态机变化（time, stateValue）
const statePoints = [
  [new Date('2025-09-12T12:00:00').getTime(), 10],
  [new Date('2025-09-12T12:12:00').getTime(), 20],
  [new Date('2025-09-12T16:30:00').getTime(), 50],
  [new Date('2025-09-12T19:00:00').getTime(), 30],
  [new Date('2025-09-12T21:00:00').getTime(), 15],
  [new Date('2025-09-12T23:10:00').getTime(), 10]
];

// 网络延迟（every 15 minutes sample）
const networkTimes = [];
const networkDelay = [];
for(let t = surgeryStart; t <= surgeryEnd; t += 15*60*1000){
  networkTimes.push(t);
  // make some synthetic variations
  const base = 120 + Math.round(Math.sin(t/3600000)*30) + Math.round(Math.random()*40);
  networkDelay.push(base > 0 ? base : 20);
}

/*******************************
 * Timeline ECharts (custom series)
 *******************************/
const timelineDom = document.getElementById('timeline');
const timelineChart = echarts.init(timelineDom);

const armNames = ['Arm 1','Arm 2','Arm 3','Arm 4']; // index 0..3

// color by type
const typeColors = {
  scalpel: '#f59e0b',
  camera:  '#2563eb',
  stapler: '#10b981',
  forceps:'#7c3aed',
  default:'#60a5fa'
};

function toOptionTimeline(){
  // create hour ticks array from start to end
  const hours = [];
  let h = new Date(surgeryStart);
  h.setMinutes(0,0,0);
  while(h.getTime() <= surgeryEnd){
    hours.push(h.getTime());
    h = new Date(h.getTime() + 60*60*1000);
  }

  // prepare data for custom series: each item [armIndex, startTs, endTs, label, udi, type]
  const data = usageBlocks.map(d => ({
    value: d,
    itemStyle: { color: typeColors[d[5]] || typeColors.default }
  }));

  return {
    tooltip: {
      trigger: 'item',
      formatter: function(param){
        if(param.seriesType === 'custom'){
          const v = param.data.value;
          const label = v[3], udi = v[4];
          const start = new Date(v[1]).toLocaleString();
          const end = new Date(v[2]).toLocaleString();
          const dur = Math.round((v[2]-v[1])/1000);
          return `<div class="tooltip-custom">
                    <div><strong>${label}</strong></div>
                    <div>UDI: ${udi}</div>
                    <div>使用时长: ${dur} s</div>
                    <div>安装时刻: ${start}</div>
                    <div>拔下时刻: ${end}</div>
                  </div>`;
        } else if(param.seriesType === 'scatter'){
          return `故障: ${param.data.code} <br/> 时间: ${new Date(param.data[0]).toLocaleString()} <br/> 等级: ${param.data.level}`;
        }
        return param.name;
      }
    },
    grid: { left:60, right:20, top:30, bottom:50, containLabel:true },
    xAxis: {
      type:'time',
      min: surgeryStart - 5*60*1000,
      max: surgeryEnd + 5*60*1000,
      axisLine:{ lineStyle:{ color:'#e6edf3' } },
      splitLine:{ show:true, lineStyle:{ color:'#eef2f6' } },
      axisTick:{ show:false },
      axisLabel:{ formatter: value => {
          const d = new Date(value);
          return `${d.getHours().toString().padStart(2,'0')}:00`;
        }},
      // show hourly grid lines by forcing interval
      interval: 60*60*1000
    },
    yAxis: {
      type:'category',
      data:['手术时间线'].concat(armNames),
      axisTick:{ show:false },
      axisLine:{ show:false },
      splitLine:{ show:false },
      inverse: false
    },
    dataZoom: [
      { type:'inside', xAxisIndex:0, filterMode:'weakFilter' },
      { type:'slider', show:true, xAxisIndex:0, bottom:0, height:16 }
    ],
    series:[
      // 状态行（在 y=0）
      {
        type:'bar',
        yAxisIndex:0,
        data:[
          { value: [(surgeryStart + surgeryEnd)/2, surgeryStart, surgeryEnd], itemStyle:{color:'#f3f6fb'} }
        ],
        silent:true,
        barWidth: 24,
        encode:{ x: [1,2], y:0 }
      },

      // custom rectangles per arm usage
      {
        type:'custom',
        name:'usage',
        renderItem: function(params, api){
          const idx = api.value(0);            // arm index
          const start = api.value(1);
          const end   = api.value(2);
          const label = api.value(3);
          const h = api.size([0,1])[1] * 0.6;
          const y = api.coord([start, idx+1])[1]; // +1 because y=0 is status line
          const xStart = api.coord([start, idx+1])[0];
          const xEnd = api.coord([end, idx+1])[0];
          const width = xEnd - xStart;
          const color = api.style().fill || '#60a5fa';

          // truncate small blocks
          const minW = 6;
          const textX = width > 60 ? xStart + 6 : xStart + Math.max(width/2 - 20, 6);

          return {
            type: 'group',
            children: [
              {
                type: 'rect',
                shape: { x: xStart, y: y - h/2, width: Math.max(width, minW), height: h, r:4 },
                style: { fill: color, stroke: '#0b4b8a', lineWidth: 0.5, opacity: 0.95 }
              },
              {
                type: 'text',
                style: { text: label, x: textX, y: y, font: `${Math.max(10, Math.min(12, h-2))}px sans-serif`, fill:'#fff', textVerticalAlign:'middle' },
                silent: true
              }
            ]
          };
        },
        encode: { x: [1,2], y: 0 },
        data: usageBlocks
      },

      // fault markers (scatter)
      {
        type:'scatter',
        name:'faults',
        data: faults.map(f => ({ value: [f[0], f[1]+1], code:f[2], level:f[3] })),
        symbolSize: 16,
        itemStyle:{
          color: function(params){
            const level = params.data.level;
            return level === 'A' ? '#ef4444' : '#f59e0b';
          }
        },
        z: 10
      },

      // mark begin/end points
      {
        type:'scatter',
        name:'beginend',
        data:[
          { value: [surgeryStart, 0], label:{ show:false } },
          { value: [surgeryEnd, 0], label:{ show:false } }
        ],
        symbol: 'diamond',
        symbolSize: 14,
        itemStyle:{ color:'#06b6d4' },
        z: 9
      }
    ]
  };
}

timelineChart.setOption(toOptionTimeline());

// 点击区块或故障事件的交互
timelineChart.on('click', function(params){
  if(params.seriesType === 'custom' && params.seriesName === 'usage'){
    // find block clicked
    const val = params.data;
    const udi = val[4];
    highlightAlarmByUDI(udi);
    // open tooltip already handled by ECharts
  } else if(params.seriesType === 'scatter' && params.seriesName === 'faults'){
    // find nearest fault and highlight row
    const code = params.data.code;
    highlightAlarmByCode(code);
    // scroll table into view
    document.getElementById('alarmTable').scrollIntoView({behavior:'smooth', block:'center'});
  }
});

/*******************************
 * State Chart & Network Chart (line charts)
 *******************************/
const stateChart = echarts.init(document.getElementById('stateChart'));
const networkChart = echarts.init(document.getElementById('networkChart'));

const stateOpt = {
  title: { text:'手术状态机变化', left:8, textStyle:{fontSize:13} },
  grid:{ left:48, right:12, top:36, bottom:22 },
  xAxis:{ type:'time', axisLine:{lineStyle:{color:'#e6edf3'}}, axisLabel:{formatter: v => { const d=new Date(v); return `${d.getHours()}:${String(d.getMinutes()).padStart(2,'0')}`; }} },
  yAxis:{ type:'value', name:'状态值', nameLocation:'middle', nameGap:44 },
  series:[{
    type:'line',
    showSymbol:false,
    data: statePoints.map(p => [p[0], p[1]]),
    areaStyle:{opacity:0.06},
    smooth:true
  }]
};
stateChart.setOption(stateOpt);

const networkOpt = {
  title: { text:'网络延时情况 (ms)', left:8, textStyle:{fontSize:13} },
  grid:{ left:48, right:12, top:36, bottom:22 },
  xAxis:{ type:'time', axisLine:{lineStyle:{color:'#e6edf3'}}, axisLabel:{formatter: v => { const d=new Date(v); return `${d.getHours()}:${String(d.getMinutes()).padStart(2,'0')}`; }} },
  yAxis:{ type:'value', name:'延时(ms)', nameLocation:'middle', nameGap:44 },
  series:[{
    type:'line',
    showSymbol:false,
    data: networkTimes.map((t,i) => [t, networkDelay[i]]),
    smooth:true,
    lineStyle:{ width:2 }
  }]
};
networkChart.setOption(networkOpt);

// connect charts (zoom/pan)
echarts.connect([timelineChart, stateChart, networkChart]);

// resize on window change
window.addEventListener('resize', () => {
  timelineChart.resize(); stateChart.resize(); networkChart.resize();
});

/*******************************
 * Alarms Table
 *******************************/
const alarmData = [
  { time: '2025-09-23 12:45:32', code: '2819211e', message: '4号工具臂4关节 Ethercat 物理断网报警', status:'已处理' },
  { time: '2025-09-23 12:50:12', code: '416d', message: '远程通信异常，判定为远程手术', status:'已处理' },
  { time: '2025-09-23 13:15:32', code: '2819211e', message: '4号工具臂网络通信状态异常', status:'已处理' },
  { time: '2025-09-23 14:05:12', code: '2a12ff1e', message: '关节参数超出阈值', status:'未处理' },
  { time: '2025-09-23 14:45:32', code: '2819211e', message: '4号工具臂 Ethercat 断连', status:'已处理' }
];

const tbody = document.getElementById('alarmTbody');
function renderAlarmTable(){
  tbody.innerHTML = '';
  alarmData.forEach((r, idx) => {
    const tr = document.createElement('tr');
    tr.dataset.idx = idx;
    tr.innerHTML = `<td>${r.time}</td><td>${r.code}</td><td>${r.message}</td><td>${r.status === '已处理' ? '<span class="badge handled">已处理</span>' : '<span class="badge unhandled">未处理</span>'}</td>`;
    tr.addEventListener('click', () => {
      // row click -> highlight and zoom timeline to that timestamp
      selectRow(idx);
      const t = new Date(r.time).getTime();
      zoomToTime(t);
    });
    tbody.appendChild(tr);
  });
}
renderAlarmTable();

function clearRowSelection(){
  Array.from(tbody.querySelectorAll('tr')).forEach(tr => tr.classList.remove('row-selected'));
}
function selectRow(idx){
  clearRowSelection();
  const tr = tbody.querySelector(`tr[data-idx="${idx}"]`);
  if(tr) tr.classList.add('row-selected');
  // scroll into view
  tr.scrollIntoView({behavior:'smooth', block:'center'});
}

// highlight alarm by UDI (simulate)
function highlightAlarmByUDI(udi){
  // in real app map udi -> alarm row(s)
  // here simply select first row
  selectRow(0);
}

// highlight by code
function highlightAlarmByCode(code){
  const idx = alarmData.findIndex(a => a.code === code);
  if(idx >= 0) selectRow(idx);
}

// zoom timeline to around t (centered)
function zoomToTime(ts){
  const range = 30*60*1000; // 30min window
  timelineChart.dispatchAction({
    type: 'dataZoom',
    // adjust start and end to new window
  });
  const start = ts - range;
  const end = ts + range;
  timelineChart.setOption({
    xAxis: [{ min: start, max: end }]
  });
  // also zoom other charts via echarts.connect
  stateChart.setOption({ xAxis:[{ min:start, max:end }] });
  networkChart.setOption({ xAxis:[{ min:start, max:end }] });
}

/*******************************
 * Export button (demo)
 *******************************/
document.getElementById('exportBtn').addEventListener('click', () => {
  const text = JSON.stringify({ usageBlocks, faults, statePoints }, null, 2);
  const blob = new Blob([text], { type:'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'surgery_data.json'; a.click();
  URL.revokeObjectURL(url);
});

/*******************************
 * Surgery selector (demo)
 *******************************/
document.getElementById('surgerySelect').addEventListener('change', (e) => {
  // in real app, fetch surgeries.structured_data for chosen surgery
  // here we just re-render same demo data
  timelineChart.setOption(toOptionTimeline());
});

</script>
</body>
</html>
